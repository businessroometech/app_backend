const validationRules: Record<string, ValidationRule> = {
  userId: { type: 'string', minLength: 10 },
  name: { required: true, type: 'string', minLength: 3 },
  description: { required: true, type: 'string' },
  eventType: { required: true, type: 'string' },
  category: { required: true, type: 'string' },
  startDatetime: { required: false, type: 'string' },
  endDatetime: { required: false, type: 'string' },
  capacity: { required: false, type: 'number', validate: (value: number) => value > 0 },
  isInviteOnly: { required: true, type: 'boolean' },
  status: { required: false, type: 'string' },
  venueName: { required: false, type: 'string' },
  addressId: { required: false, type: 'string' },
  bannerImageUrl: { required: true, type: 'string' },
  livestreamLink: { required: false, type: 'string' },
  accessCode: { required: false, type: 'string' },
  registrationDeadline: { required: false, type: 'string' },
  schedules: { required: false },
  dressCodes: { required: false },
  eventMedia: { required: false },
  eventRules: { required: false },
  isDraft: { required: false, type: 'boolean' },
  ticketType: { required: false, type: 'string', minLength: 3 },
  price: { required: false, type: 'number' },
  quantityAvailable: { required: true, type: 'number' },
  isFree: { required: false, type: 'boolean' },
  inclusions: { required: false, type: 'string', minLength: 3 },
};

// Function to create or update an event
export const createOrUpdateEvent = async (req: Request, res: Response) => {
  // Validate request body
  const errors = validateRequestBody(req.body, validationRules);
  if (errors) {
    return res.status(400).json({ errors });
  }

  try {
    const {
      userId,
      eventId,
      name,
      description,
      eventType,
      category,
      startDatetime,
      endDatetime,
      capacity,
      isInviteOnly,
      status,
      venueName,
      addressId,
      bannerImageUrl,
      livestreamLink,
      accessCode,
      registrationDeadline,
      organizerImgUrl,
      organizerName,
      organizerPhone,
      organizerEmail,
      organizerSocialMedialatform,
      organizerSocialMediaLink,
      schedules,
      dressCodes,
      eventMedia,
      eventRules,
      isDraft,
      ticketType,
      price,
      quantityAvailable,
      isFree,
      inclusions,
    } = req.body;

    // Validate user ID
    const user = await validateUserId(userId, res);
    if (!user) return;

    // Select repository based on draft status
    const eventRepository = isDraft ? AppDataSource.getRepository(EventDraft) : AppDataSource.getRepository(Event);
    const ticketRepository = AppDataSource.getRepository(Ticket);

    let event;

    if (eventId) {
      // Update existing event
      event = await eventRepository.findOne({ where: { id: eventId } });
      if (!event) {
        return res.status(404).json({
          status: 'error',
          message: 'Event not found',
        });
      }
      Object.assign(event, {
        userId,
        name,
        description,
        eventType,
        category,
        startDatetime,
        endDatetime,
        capacity,
        isInviteOnly,
        status,
        venueName,
        addressId,
        bannerImageUrl,
        livestreamLink,
        accessCode,
        registrationDeadline,
        organizerImgUrl,
        organizerName,
        organizerPhone,
        organizerEmail,
        organizerSocialMedialatform,
        organizerSocialMediaLink,
      });
    } else {
      // Create new event
      event = eventRepository.create({
        userId,
        name,
        description,
        eventType,
        category,
        startDatetime,
        endDatetime,
        capacity,
        isInviteOnly,
        status,
        venueName,
        addressId,
        bannerImageUrl,
        livestreamLink,
        accessCode,
        registrationDeadline,
        organizerImgUrl,
        organizerName,
        organizerPhone,
        organizerEmail,
        organizerSocialMedialatform,
        organizerSocialMediaLink,
        schedules,
      });
    }

    // Save the event to the database
    const savedEvent = await eventRepository.save(event);
    const eventIdFinal = savedEvent.id;

    if (!isDraft) {
      // Save ticket details if not a draft
      const ticket = ticketRepository.create({
        eventId: eventIdFinal,
        ticketType,
        price: isFree ? 0 : price,
        quantityAvailable,
        isFree,
        inclusions,
      });
      await ticketRepository.save(ticket);
    }

    // Handle related entities
    if (dressCodes) {
      await saveRelatedEntities(AppDataSource.getRepository(DressCode), dressCodes, eventIdFinal);
    }
    if (eventMedia) {
      await saveRelatedEntities(AppDataSource.getRepository(EventMedia), eventMedia, eventIdFinal);
    }
    if (eventRules) {
      await saveRelatedEntities(AppDataSource.getRepository(EventRule), eventRules, eventIdFinal);
    }
    if (schedules) {
      await saveRelatedEntities(AppDataSource.getRepository(EventSchedule), schedules, eventIdFinal);
    }

    // Delete draft event if published
    if (!isDraft) {
      const draftRepository = AppDataSource.getRepository(EventDraft);
      const draftEvent = await draftRepository.findOne({ where: { id: eventIdFinal } });
      if (draftEvent) {
        await draftRepository.remove(draftEvent);
      }
    }

    const message = eventId ? 'Event updated successfully' : 'Event created successfully';
    return res.status(200).json({
      status: 'success',
      message: isDraft ? 'Event saved in draft' : message,
      data: { event: savedEvent },
    });
  } catch (error) {
    console.error('Error while creating or updating the event:', error);
    return res.status(500).json({
      status: 'error',
      message: 'An error occurred while processing the event.',
    });
  }
};

// Helper function to save related entities
const saveRelatedEntities = async (repository, data, eventId) => {
  const mappedData = data.map((item) => ({
    ...item,
    eventId,
  }));
  await repository.save(mappedData);
};
